{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getIn = getIn;\nexports.default = void 0;\n\nvar _propertyExpr = require(\"property-expr\");\n\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\n\nfunction getIn(schema, path, value, context) {\n  if (context === void 0) {\n    context = value;\n  }\n\n  var parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n\n    if (schema.innerType) {\n      var idx = isArray ? parseInt(part, 10) : 0;\n\n      if (value && idx >= value.length) {\n        throw new Error(\"Yup.reach cannot resolve an array item at index: \" + _part + \", in the path: \" + path + \". \" + \"because there is no value at that index. \");\n      }\n\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(\"The schema does not contain the path: \" + path + \". \" + (\"(failed at: \" + lastPartDebug + \" which is a type: \\\"\" + schema._type + \"\\\")\"));\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\n\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\n\nvar _default = reach;\nexports.default = _default;","map":{"version":3,"sources":["/Users/dc/The Beautiful Revolution/Websites/The Beautiful Revolution/Mach 3/TheBeautRev/client/node_modules/yup/lib/util/reach.js"],"names":["exports","__esModule","getIn","default","_propertyExpr","require","trim","part","substr","length","schema","path","value","context","parent","lastPart","lastPartDebug","parentPath","forEach","_part","isBracket","isArray","resolve","innerType","idx","parseInt","Error","fields","_type","reach","obj","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.getIn = getIn;\nexports.default = void 0;\n\nvar _propertyExpr = require(\"property-expr\");\n\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\n\nfunction getIn(schema, path, value, context) {\n  if (context === void 0) {\n    context = value;\n  }\n\n  var parent, lastPart, lastPartDebug; // root path: ''\n\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n\n    if (schema.innerType) {\n      var idx = isArray ? parseInt(part, 10) : 0;\n\n      if (value && idx >= value.length) {\n        throw new Error(\"Yup.reach cannot resolve an array item at index: \" + _part + \", in the path: \" + path + \". \" + \"because there is no value at that index. \");\n      }\n\n      parent = value;\n      value = value && value[idx];\n      schema = schema.innerType;\n    } // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we'll handle the `child` part on the next iteration like normal\n\n\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error(\"The schema does not contain the path: \" + path + \". \" + (\"(failed at: \" + lastPartDebug + \" which is a type: \\\"\" + schema._type + \"\\\")\"));\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n\n    lastPart = part;\n    lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\n\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\n\nvar _default = reach;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}